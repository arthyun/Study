{
    "quiz" : [
        {
            "id": 1,
            "exam": "브라우저 렌더링 원리를 서술하시오",
            "answer": "서버로 부터 받은 HTML, CSS를 다운받은 후 HTML, CSS파일을 Object Model로 만든다. HTML은 DOM(문서객체모델)로, CSS는 CSSOM으로 만들어진다.(DOM Tree, CSSOM Tree 생성됨) -> Render Tree가 생성되기 위해 DOM Tree와 CSSOM Tree가 합쳐진다. Render Tree에는 스타일 정보 및 실제 화면에 표현되는 노드들로 구성된다. -> Layout 단계: 브라우저의 Viewport내에서 노드들의 정확한 위치와 크기를 계산한다. 생성된 Render Tree 노드들이 가지고 있는 스타일과 속성에 따라서 브라우저 화면의 어느위치에 어느크기로 출력될지 계산하는 단계이다. -> Paint 단계: Layout 계산이 완료되면 요소들을 실제 화면에 그리게된다. 처리하기 복잡할수록 그리는데에 소요되는 시간이 길다."
        },
        {
            "id": 2,
            "exam": "호이스팅에 대해 설명해보시오",
            "answer": "변수를 선언하고 초기화했을 때, 선언 부분이 최상단으로 끌어올려지는 현상을 말한다. var의 경우 변수를 선언하고 초기화하는 과정이 동시에 일어나서 호이스팅이 발생한다. 반면 const/let의 경우 선언과 초기화 단계가 동시에 일어나지 않는다. 실행 시점에서 실제 선언부를 만날 때 초기화가 이뤄진다. 그 사이 시간을 TDZ라고 부른다. 즉 실행 컨텍스트에 변수가 선언은 되었으나 메모리가 할당되지 않아 ReferenceError가 발생한다. 함수(Function) 호이스팅은 선언문에서 발생한다. 선언된 함수는 상단에서 참조, 호출이 가능하다. 함수 표현식은 결국 변수에 할당하는 모습이라 변수 호이스팅의 사례로 볼 수 있다."
        },
        {
            "id": 3,
            "exam": "클로저는 무엇인가요? 원리와 왜 사용하는지?",
            "answer": "함수와 해당 함수가 선언된 렉시컬 환경의 조합이다. 외부함수가 반환된 후에도 외부함수의 변수 범위 체인에 접근할 수 있는 함수이다. 전역변수의 사용을 억제하고, 정보를 은닉하기 위해 사용한다."
        },
        {
            "id": 4,
            "exam": "this의 용법을 아는대로 설명하시오",
            "answer": "this는 함수를 호출할 때 결정되는 것이며, 전역범위 및 함수에서 사용될때는 전역객체인 window를 가르킨다. 객체에 속한 메소드에서 사용될때 그 메소드의 객체(점 앞에 명시된 객체)를 가르킨다. 객체에 속한 내부함수에서 사용될땐 전역객체를 가르킨다. 생성자에서 사용될때 생성자로 인해 생성된 새로운 객체를 가르킨다. 화살표 함수에서 this는 동적으로 바인딩 되지 않으며 항상 상위 스코프의 실행 컨텍스트를 따라간다."
        },
        {
            "id": 5,
            "exam": "브라우저 저장소(쿠키, 세션, 로컬스토리지)에 대한 차이점을 설명해주세요",
            "answer": "만료기한이 있는 쿠키의 단점을 보완해 로컬스토리지가 만들어졌다. 로컬스토리지는 client의 정보를 영구적으로 저장하는 반면 세션 스토리지는 브라우저를 종료할 경우 정보가 삭제된다. 쿠키는 로컬&세션에 비해 용량이 매우작고 암호화가 없어 정보 도난 위험이있다."
        },
        {
            "id": 6,
            "exam": "이벤트 버블링과 캡쳐링에 대해 말씀해주세요",
            "answer": "어떤 요소에 대한 이벤트가 발생했을 때, 해당 요소의 최상위 부모까지 이벤트가 전달되어지는 과정이다. HTML 구조상 자식 요소에 발생한 이벤트가 상위 부모요소에 영향을 미치는 것이다. 이벤트 캡쳐링은 정반대로서 최상위 부모에서 이벤트 발생 요소까지 이벤트가 전달 되는 것이다. 버블링이나 캡처링을 차단하고자 할땐 e.stopPropagation을 호출하면 이벤트 전파를 막고 해당 이벤트만 실행시킬 수 있다."
        },
        {
            "id": 7,
            "exam": "타입스크립트를 사용하는 이유는 무엇인가요?",
            "answer": "JS기반의 언어이며 JS의 상위확장버전이다. 정적타입으로 컴파일 단계에서 오류를 포착할 수 있는 장점이 있고, 강력한 OOP 프로그래밍을 지원합니다. ES6의 새로운 기능들을 사용하기 위해 바벨과 같은 별도 트랜스파일러를 사용하지 않아도 ES6의 새로운 기능을 기존 JS엔진에서 실행 가능합니다. 명시적인 정적 타입 지정은 코드의 가독성을 높이고 디버깅을 쉽게 한다."
        },
        {
            "id": 8,
            "exam": "CSR과 SSR의 차이점은 무엇인가요?",
            "answer": "SSR은 사용자가 웹 페이지에 접근 할때, 서버에 각각 페이지에 대해 요청하고 서버에서 HTML, JS 파일 등을 모두 다운로드하여 화면에 렌더링 하는 방식이다. CSR은 클라이언트측에서 HTML, JS, 리소스 파일들을 받은 이후에 브라우저에서 렌더링을 진행하는 것으로, JS가 동작하면서 데이터만을 주고 받는다."
        },
        {
            "id": 9,
            "exam": "React, Vue, Angular의 차이는 무엇인가요?",
            "answer": "공통점은 SPA기반 FE 프레임워크/라이브러리인 것이다. React는 단방향 바인딩으로 부모 컴포넌트에서 props가 자식 컴포넌트로 전달되는 라이브러리다., Vue나 angular는 양방향 바인딩이 구현 가능하다는 차이가 있다. Learning Curve는 Vue가 가장 낮고, React는 Jsx문법을 사용하며, 개발 생태계가 가장 잘 활성화 되어있다. 대규모 프로젝트 개발에 유리하다. Vue와 angular는 프레임워크이다. angular는 TS를 사용함으로써 코드의 가독성과 안정성이 좋지만 Learning Curve가 크다."
        },
        {
            "id": 10,
            "exam": "React의 상태관리 방법에 대해서 설명하시오",
            "answer": "Redux, MobX, Context API 등의 라이브러리를 사용한 방법이 있다. 가장 많이 사용되는 Redux는 전역 상태를 생성하고 관리하며, 상태관리 라이브러리 중 가장 압도적으로 많이 사용된다. Redux는 컴포넌트에서 Action Creater를 통해 Action을 만들고 그 Action을 Dispatch 함수로 실행시킨다. 그러면 Store에서 해당 Reducer로 매칭되는 Action이 있는지 확인하고 Store에 저장된 상태를 변경해주는 원리로 작동한다. Redux는 Context API와 다르게 전역 상태 관리 외에도 redux-saga, redux-thunk 등 추가 라이브러리를 통해 비동기 작업을 쉽게 해줄 수 있는 장점이 있지만, 코드가 많고 복잡하기 때문에 이런 부가기능이 필요하지 않은 소규모 프로젝트에는 Context API를 쓰는 것이 나을 수 있다."
        },
        {
            "id": 11,
            "exam": "React의 라이프사이클에 대해 설명해주세요",
            "answer": "컴포넌트의 수명 주기가 존재하는데, 컴포넌트의 수명은 보통 페이지에서 렌더링되기 전인 준비 과정에서 시작해 페이지에서 사라질 때 끝이난다. 라이프 사이클은 총 9개의 과정이 존재하는데 크게는 컴포넌트가 처음 실행될때인 Mount(생성), 데이터에 변화가 있을때인 Update(변화), 컴포넌트가 제거될 때인 Unmount(제거) 이렇게 세가지로 나눌 수 있다."
        },
        {
            "id": 12,
            "exam": "var, let, const의 차이점",
            "answer": "const/let는 블록 스코프를 갖고 공통적으로 재선언이 되지 않는다. 그러나 let는 재 할당이 가능하고, const는 선언과 동시에 할당이 되기에 재할당이 불가능하다."
        },
        {
            "id": 13,
            "exam": "MVC, MVVM 모델에 대해 설명하세요***",
            "answer": "MVC패턴은 모델 + 뷰 + 컨트롤러를 합친 용어이다. 모델은 데이터 및 데이터를 처리하는 부분이고, view는 사용자에게 보여지는 UI 부분이다. 컨트롤러는 사용자의 입력을 받고 처리하는 부분이다. MVC는 사용자의 액션이 컨트롤러에 들어오면, 컨트롤라가 액션을 확인하고 모델을 업데이트한다. 컨트롤러는 모델을 나타내줄 view를 선택하고, view는 모델을 이용하여 화면을 나타낸다. 컨트롤러는 여러개의 view를 선택할 수 있는 1:n 구조이고, 뷰를 선택할 뿐 직접 업데이트는 하지 않는다. 보편적으로 널리 사용되는 패턴이며, 단점은 뷰와 모델사이의 의존성이 높고, 어플리케이션이 커질수록 복잡하고, 유지보수가 어렵다는 점이다. MVVM 패턴은 모델+뷰+뷰모델을 합친 용어이고, 모델과 뷰는 MVC와 동일하다. 뷰모델은 뷰를 표현하기 위해 만든 뷰를 위한 모델이다. 뷰를 나타내 주기 위한 모델이자, 뷰를 나타내기 위해 데이터 처리를 하는 부분이다. 액션이 뷰를 통해 들어오면, 뷰 모델에 액션을 전달한다. 뷰 모델은 모델에게 데이터를 요청하고, 모델은 요청받은 데이터를 뷰 모델에게 응답하고, 뷰 모델은 받은 데이터를 가공하여 저장한다. 뷰는 뷰 모델과 데이터 바인딩을 하여 화면을 그리는 동작 방식이다. 이 패턴의 가장 큰 장점은 뷰와 뷰 모델의 의존성을 없애고, 각 부분이 독립적이라는 것이다. 단점은 뷰 모델의 설계가 쉽지 않다는 점이다. 이 패턴의 주요 목적은 로직의 분리이다. 리액트에서는 데이터와 화면 컴포넌트를 분리하는 것을 예시로 들 수 있다."
        },
        {
            "id": 14,
            "exam": "CSS의 Flex 속성을 설명해주세요.",
            "answer": "Flexbox란 기존 컨텐츠를 수평으로 배치할 때, float나 inline-block으로 마크업할때의 불편함을 쉽게 해결할 수 있도록 추가된 기능이다. 다양한 디바이스 환경에서 언제나 똑같은 레이아웃을 유지시켜줌으로써 반응형 웹 사이트에 유용하게 쓰인다."
        },
        {
            "id": 15,
            "exam": "주소창에 google.com / naver.com을 입력하면 생기는 일***",
            "answer": "사용자가 입력한 url 주소 중에서 도메인 네임을 DNS 서버에서 검색한다. -> DNS 서버에서 해당 도메인 네임에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달함. -> 웹 페이지 URL + IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성한다 -> HTTP 요청 메세지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다 -> 이렇게 도착한 HTTP 요청 메세지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환된다. -> 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색한다 -> 검색된 웹 페이지 데이터는 또다시 HTTP 프로토콜을 사용하여 HTTP 응답 메세지를 생성한다 -> 이렇게 생성된 HTTP 응답 메세지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전달된다. -> 도착한 HTTP 응답 메세지는 HTTP 프로토콜을 이용하여 웹 페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다."
        },
        {
            "id": 16,
            "exam": "HTTP와 HTTPS의 차이점은?",
            "answer": "HTTP는 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜이다. HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜이다. 공개키/개인키 암호화 방식을 이용해 데이터를 암호화한다. HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요하기 때문에 HTTP보다 속도가 느리다(그러나 실 사용에서는 크게 차이는 없다.)"
        },
        {
            "id": 17,
            "exam": "OOP의 특징에 대해서 설명하시오",
            "answer": "객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법으로 OOP의 장점은 코드 재사용성이다."
        },
        {
            "id": 18,
            "exam": "useMemo vs useCallback의 차이점을 설명해주세요.",
            "answer": "둘다 메모이제이션 훅으로 연산 된 값을 자료구조에 저장 후 재사용시 계산을 반복하지않고 꺼내서 사용가능하게 해준다. 메모이제이션 훅은 리액트의 불필요한 랜더링(예: 자식 컴포넌트의 상태가 변경되지않아도 랜더링 해버리는 경우)을 방지하여 퍼포먼스 최적화에 사용된다. 둘의 차이점은 useCallback은 전달된 함수 그 자체를 캐싱하지만, useMemo는 전달된 함수가 실행되고 반환된 결과를 캐싱한다는 것이다.(=useMemo는 메모이제이션 된 값을 반환하고 useCallback은 메모이제이션 된 콜백을 반환한다.)"
        },
        {
            "id": 19,
            "exam": "*동기와 비동기에 대해 설명해주세요.",
            "answer": "동기는 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속이다. 바로 요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 한다. 순서에 맞춰 진행되는 장점이 있지만, 여러가지 요청을 동시에 처리할 수 없다. 비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을 거라는 약속이다. 하나의 요청에 따른 응답을 즉시 처리하지 않아도, 그 대기 시간동안 또 다른 요청에 대해 처리 가능한 방식이다. 여러 개의 요청을 동시에 처리할 수 있는 장점이 있지만 동기 방식보다 속도가 떨어질 수도 있다."
        },
        {
            "id": 20,
            "exam": "*Promise란?",
            "answer": "비동기 동작을 다루기 위한 패턴으로, 비동기 요청을 보내면 성공 또는 실패가 다양한 형태로 발생한다. 프로미스를 사용하면 이러한 성공(resolve)이나 실패(reject)를 편리한 방식으로 환원할 수 있다. new 연산자와 함께 호출한 promise의 인자로 넘겨주는 콜백함수는 호출할 때 바로 실행, 그 내부에 resolve 또는 reject 함수를 호출하는 구문이 있으면 둘 중 하나가 실행되기 전까지는 다음 then or catch 구문으로 넘어가지 않는다. pending, fulfilled, rejected 3가지 상태를 가진다."
        },
        {
            "id": 21,
            "exam": "*Async, Await와 Promise의 차이는?",
            "answer": "기존 Promise 사용 시 .catch()문으로 에러를 핸들링 가능했지만, async/await는 에러 핸들링 기능이 따로 없어 try-catch()문을 활용해야한다. Promise는 .then() 지옥의 가능성이 있어, 코드가 길어질수록 async/await문을 사용하면 가독성이 좋으며, await는 항상 async 내부에 존재해야 한다."
        },
        {
            "id": 22,
            "exam": "ESLint에 대해 설명해주세요.",
            "answer": "자바스크립트 언어와 소스코드를 분석하는 도구로 eslint패키지를 설치해주면 코드에 특정 스타일과 규칙을 적용해 에러를 찾고 패턴을 적용시킬 수 있는 분석 툴이다. 사용시 ECMAScript코드에서 문제점을 검사하고 일부는 더 나은 코드로 정정해주는 유용한 도구이다. 코드의 가독성을 높이고 잠재적인 오류와 버그를 제거해 단단한 코드를 만드는 것이 목적이다. 추가로 코드를 더 보기좋도록 포맷팅 해주는 prettier를 ESLint와 함께 사용해주면 더 효율적이다."
        },
        {
            "id": 23,
            "exam": "*ES6 문법에 추가된 것들을 아는대로 설명하세요",
            "answer": "let, const 선언키워드 도입 / class 문법 도입 / 객체 리터럴이 강화 됨 / 화살표 함수 도입 / 전개구문인 ...을 도입 / 백틱 도입 / 모듈(import, export) 도입 / Promise 도입 / map 함수 도입"
        },
        {
            "id": 24,
            "exam": "*DOM과 가상 DOM이란?",
            "answer": "Document Object Model의 약자로, HTML 요소들을 구조적으로 표현한 것이다. 돔 트리의 노드를 탐색하거나 수정할 수 있는 api를 제공한다. DOM은 트리구조로 되어있어 이해하기 쉽지만, 노드의 수가 많아질수록 속도가 느려지고, DOM 업데이트는 잦은 오류와 UI에 악영향을 끼친다. 가상 DOM은 실제 DOM 문서를 추상화한 개념으로, 변화가 많은 view를 실제 DOM에서 직접 처리하는 방식이 아닌 가상 DOM과 메모리에서 미리 처리하고 저장한 후 실제 DOM과 동기화하는 프로그래밍 개념이다."
        },
        {
            "id": 25,
            "exam": "웹팩과 바벨은 무엇인가?",
            "answer": "바벨은 모든 실행환경(IE포함)에서 자바스크립트가 정상적으로 동작할 수 있도록 ES6 코드를 ES5코드로 변환해주고, 리액트의 JSX, TS 까지 변환해주는 자바스크립트 컴파일러이다. 특정 버전이상에만 실행되는 코드 or 특정 브라우저에서는 실행되지 않는 코드들을 정상적으로 동작하게 만들어준다. 웹팩은 프로젝트의 구조를 분석하고 자바스크립트 모듈을 비롯한 관련 리소스들을 찾은 다음 이를 브라우저에서 사용할 수 있는 번들로 묶고 패킹하는 모듈 번들러(Module bundler)다. 모듈 번들러는 여러개의 나누어져 있는 파일들을 하나로 만들어주는 라이브러리이고, 웹페이지를 보여주기 위해 수많은 파일을 서버에 개별적으로 요청하는 것이 아닌 하나로 줄여서 요청하여 코드를 압축하고 최적화해준다."
        },
        {
            "id": 26,
            "exam": "JWT 방식을 설명하고, 왜 사용했는지?",
            "answer": "JWT는 JSON Web Token의 약자로, 데이터가 JSON으로 이루어져 있는 토큰을 말한다. 기존의 세션인증방식은 인증 관련 정보를 세션 저장소라는 DB에 저장했기 때문에 서버가 과부하 되거나 서버를 확장하기 어려웠다. 이를 보완하기 위해( = 서버자원을 절약) 사용자 인증에 필요한 정보를 토큰 자체에 담고 있어 별도 저장소에 정보를 저장해 둘 필요가 없는 JWT을 사용하게 되었다. 토큰은 로그인 이후 서버가 만들어주는 문자열이고, 문자열 안에는 사용자의 로그인 정보와 서버의 서명이 들어있다. 사용자가 로그인을 하면 서버는 사용자에 토큰을 발급하고, 사용자는 토큰과 함께 다른 API 작업을 요청한다. 서버는 토큰의 유효성 검사를 통해 요청한 것에 대한 응답을 해준다. 단 한번 발급된 토큰은 수정 및 폐기가 불가하다는 단점이 있고, 유효기간을 짧게 지정해주는 것이 중요하다."
        },
        {
            "id": 27,
            "exam": "*async/awiat이란?",
            "answer": "async와 await는 자바스크립트의 비동기 처리 패턴 중 가장 최근에 나온 문법입니다. 기존의 비동기 처리 방식인 콜백 함수와 프로미스의 단점을 보완하고 개발자가 읽기 좋은 코드를 작성할 수 있게 도와줍니다."
        },
        {
            "id": 28,
            "exam": "Redux가 무엇인지 그리고 장단점 설명",
            "answer": "리덕스란 현재 가장 많이 사용되고 있는 상태관리 라이브러리다. 컴포넌트의 상태 관련 로직을 따로 분리시켜 효과적으로 관리 할 수 있고, 상태를 공유할 때에도 다른 컴포넌트를 거치지 않고 Store를 통해 전달이 가능해서 편리하다. 그리고 미들웨어라는 기능을 제공하여 비동기 작업을 훨씬 효율적으로 관리 할 수 있다 프로젝트할 때 각 로그인 여부에 따라 댓글 창을 활성화시켰는데 리덕스를 사용하지 않았다면 여러 컴포넌트를 거쳐서 로그인 상태를 받았어야 했는데 store에 연결만하면 바로 알 수 있어서 편하게 진행 할 수 있었다. 리덕스에서 데이터를 가공하기 위해선 액션이란 것을 만들어야한다. 그 액션의 이름을 type이라고 하고, 그 액션을 디스패치를 해야지만 Store내에 있는 데이터가 바뀐다. 또한 그 액션들이 어떻게 동작해야하는지 구현을 해서 저장해 두는 곳을 리듀서라고 한다. 리덕스의 단점은 데이터를 다를 때마다 액션을 하나하나 만들어야하는 번거로움이 있다. +코드량 증가"
        },
        {
            "id": 29,
            "exam": "리액트 Hook에 대해 설명하시오",
            "answer": "리액트 훅은 리액트 16.8 버전에서 새롭게 추가된 사용방법으로 함수형 컴포넌트에서도 클래스형 컴포넌트의 기능을 사용할 수 있게 한다. 함수형 컴포넌트에서 상태값을 관리할수도, 생명주기 함수 또한 이용할 수 있다. 훅을 사용하면 재사용 가능한 로직을 쉽게 만들 수 있고, 또 React의 내장된 훅 말고 새로운 커스텀 훅을 만들수도 있다. 또한 코드 가독성이 좋아지는 장점이 있다."
        },
        {
            "id": 30,
            "exam": "CORS란? CORS를 위한 처리를 했는지, 해결 방법?",
            "answer": "CORS는 도메인 혹은 포트가 다른 서버의 자원을 요청할 때 생긴다. 그러나 동일 출처 정책으로 인해 CORS같은 상황이 발생하면 외부서버에 요청한 데이터를 브라우저에서 보안목적으로 차단을 한다. 해당 문제를 해결하려면 response헤더에 'Access-Control-Allow-Origin'를 추가하던가, 서버 쪽에서 처리를 해주면 된다."
        },
        {
            "id": 31,
            "exam": "*REST API란?",
            "answer": "REST API는 'REST하게 클라이언트와 서버간에 데이터를 주고받는 방식'인데, 여기서 REST란 HTTP URI를 통해 자원을 명시하고, HTTP메소드(POST, GET, PUT, DELETE)를 통해 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것이다. REST의 특징에는 Uniform Interface, 무상태성이 있다."
        },
        {
            "id": 32,
            "exam": "클래스형 컴포넌트와 함수형 컴포넌트를 비교해주세요.",
            "answer": "React에서 컴포넌트를 선언하는 2가지 방식이며, 클래스형의 경우 state의 사용이 가능하여 상태 저장이 가능하고, 생명주기(Life cycle) 메소드를 사용할 수 있다. 함수가 아닌 클래스이기 때문에 return문이 없고 render()함수가 필수적으로 있어야 Jsx 반환이 가능하다. 함수형 컴포넌트보다 먼저 나왔기 떄문에 유지보수를 한다면 알아두어야 한다. 함수형 컴포넌트는 클래스보다 선언하기 좀 더 편하고, 함수는 한번 실행되고 나면 메모리 상에서 사라지기 떄문에 메모리 자원을 덜 사용하고 가독성이 좋다는것이 장점이다. 함수형 컴포넌트에서는 Hook을 사용할 수 있고, return문을 통해 Jsx를 반환한다."
        },
        {
            "id": 33,
            "exam": "redux-thunk를 사용한 이유와 작동원리에 대해 설명하시오",
            "answer": "(원리를 잘 모르겠음 아직...)"
        },
        {
            "id": 34,
            "exam": "*props와 state에 대해 설명해주세요",
            "answer": "props와 state 모두 React 컴포넌트에서 다루는 데이터로 그 중 props는 부모 컴포넌트에서 받아온 데이터이다. React는 부모에서 자식으로만 데이터가 흐르는 단방향 형식으로, 이미 상속된 props는 수정이 불가능하다. 반면 state는 해당 컴포넌트 내부에서 선언되기때문에 수정이 가능하다는 차이점이 있다. -> 문제점: setState를 사용하여 state값을 업데이트 해주면 자동으로 재 렌더링되지만 주의할 점은 setState의 비동기적 특성을 기억하고 사용 해야한다. (setState가 있을 경우, 리액트는 다른 state변경까지 한꺼번에 통합해서 리액트 자신이 판단하기에 가장 적절한 시기에 돔을 재 렌더링한다. 해결하기 위해 콜백 혹은 useEffect를 사용한다.)"
        },
        {
            "id": 35,
            "exam": "call, apply, bind의 차이점은 무엇인가요?",
            "answer": "this가 함수 호출식에 따라 객체를 가르켰다면 call apply bind는 함수가 직접 실행문맥을 결정한다. 그 중 call과 apply의 첫번째 인자는 대상 객체로 호출될 함수이며, 두번째로 인자는 호출할 함수의 인수들로서 배열일 경우는 apply를 사용한다. bind는 this를 가리키는 새로운 함수를 생성할 수 있게 해준다."
        },
        {
            "id": 36,
            "exam": "AJAX에 대해 자세히 설명하세요(+장단점)",
            "answer": "Asynchronous JavaScript And XML의 약자로, 자바스크립트를 이용하여 비동기식으로 XML을 이용해 서버와 통신하는 방식이다. 최근에는 XML보다 JSON을 많이 사용한다. 웹 페이지 전체를 업데이트 하는게 아니라 부분적으로 업데이트를 하기 위해 사용한다. -> 장점: 페이지를 업데이트 시 새로고침 없이 필요한 부분만 업데이트해서 빠르다. -> 단점: History관리가 안돼며, 보안상의 문제가 생기며, 연속으로 데이터 요청 시 서버 부하가 증가할 수 있다."
        },
        {
            "id": 37,
            "exam": "use strict 이 무엇인가요? 사용시 장단점이 무엇인가요?",
            "answer": "자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다. -> 코드의 문제를 빠르게 파악하여 디버깅이 쉬워지고 속도가 빠르다, 단점으로는 엄격모드보다 속도가 느리며, 엄격모드를 지원하지 않는 브라우저에서는 엄격모드의 코드가 다른 방식으로 동작할 수 있다."
        },
        {
            "id": 38,
            "exam": "Box model에 대해 설명해주세요.",
            "answer": "모든 HTML 요소는 BOX모양으로 구성되며, 이것을 박스모델이라고 한다. 개발자 도구 Element > Styles 하단에서 확인가능. 박스 모델은 총 네 부분(영역)으로 이루어지고, 이 네가지 부분은 바깥부터 margin, border, padding, content로 구분된다."
        },
        {
            "id": 39,
            "exam": "Prototype이란? Prototype Chaining은?",
            "answer": "객체가 만들어지기 위해서는 자신을 만드는데 사용된 원형인, 프로토타입 객체를 생성한다. 생성된 객체 내에 __proto__ 속성이 자신을 만들어낸 원형을 의미하는 프로토타입이다. 특정 속성을 찾을때 상위 프로토타입을 타고 쭉 올라가면서 찾는데 이를 프로토타입 체이닝이라고 한다. 최상위 프로토타입은 Object의 Prototype Object이다. 여기까지 값을 찾고 없다면 undefined를 출력한다."
        },
        {
            "id": 40,
            "exam": "undeclared 란? (null, undefined와 비교)",
            "answer": "undefined과 null의 차이는 둘다 선언은 되어있지만, 값의 할당 차이이다. Undefined: 접근 가능한 스코프에 변수가 선언되었으나 현재 아무런 값도 할당되지 않은 상태. Null: 변수를 선언하고 'null' 이라는 빈값을 할당한 경우 (null은 객체임). Undeclared: 접근 가능한 스코프에 변수 선언조차 되어있지 않은 상태."
        },
        {
            "id": 41,
            "exam": "forEach와 Map의 차이점은?",
            "answer": "리턴값이 있냐 없냐의 차이인데... 설명: forEach는 원본을 변경시키며, map은 원본은 두고 새로운 배열을 반환한다."
        },
        {
            "id": 42,
            "exam": "***이벤트 루프란?",
            "answer": "싱글 스레드 기반의 언어인 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원한다. 이벤트 루프는 콜스택과 콜백큐의 상태를 체크하여, 콜스택이 빈 상태가 되면 콜백큐의 첫번째 콜백을 콜스택으로 밀어주는 역할을 한다. -> 즉, 자바스크립트 엔진이 코드 조각을 하나씩 처리할 수 있도록 작업을 스케쥴하는 동시에 JS에서 비동기 작업을 처리할 수 있게 해준다. 모든 비동기 방식의 API들(setTimeout, ajax 등)은 이벤트 루프를 통해 콜백 함수를 실행한다고 볼 수 있다."
        },
        {
            "id": 43,
            "exam": "화살표 함수와 일반함수의 차이점",
            "answer": "화살표 함수는 일반 함수보다 표현이 간단하며, 익명함수 또는 이름이 없는 함수, 즉시 실행이 필요할 경우 사용하는 함수다. 일반 함수는 this가 동적으로 바인딩되는 반면, 화살표 함수는 바로 상위 스코프의 this와 같다. 또한 화살표 함수는 프로토타입 속성을 가지고 있지 않기때문에 생성자 함수로 사용이 어렵고, 일반함수에서는 함수가 실행될때 암묵적으로 arguments 변수가 전달되어 사용할 수 있지만, 화살표 함수에서는 arguments 변수가 전달되지 않는다."
        },
        {
            "id": 44,
            "exam": "'==' 와 '==='의 차이",
            "answer": "'=='는 동등 연산자로, 비교하는 대상의 타입이 다르더라도, 강제로 비교한다. '==='는 일치 연산자로 동등 연산자보다 엄격하게 비교한다. 타입과 값이 모두 같을 경우에만 true를 리턴한다."
        },
        {
            "id": 45,
            "exam": "***깊은복사, 얕은복사란?",
            "answer": "깊은복사된 객체는 객체 안에 객체가 있을 경우에도 원본과의 참조가 완전히 끊어진 객체를 말합니다. 얕은복사란 객체를 복사할 때 기존 값과 복사된 값이 같은 참조를 가리키고 있는 것을 말합니다. 객체 안에 객체가 있을 경우 한 개의 객체라도 기존 변수의 객체를 참조하고 있다면 이를 얕은 복사라고 합니다. -> 얕은 복사는 객체의 참조값(주소 값)을 복사하고, 깊은 복사는 객체의 실제 값을 복사합니다. "
        },
        {
            "id": 46,
            "exam": "고차 컴포넌트(HOC)란? 사용해본 적 있는지?",
            "answer": "고차 컴포넌트는 컴포넌트를 취하여 새로운 컴포넌트를 반환하는 함수입니다. 즉 리액트 컴포넌트를 인자로 받아서 새로운 리액트 컴포넌트를 리턴하는 함수이다. 컴포넌트 로직을 재사용하기 위한 아주 고오급 리액트 기술이고, 유저 인증 로직 처리 혹은 로딩 중 화면 처리, 컨테이너 컴포넌트와 프레젠테이션 컴포넌트를 분리하는 등에 자주 활용된다."
        },
        {
            "id": 47,
            "exam": "이벤트 바인딩이란?",
            "answer": "이벤트 바인딩이란, 발생하는 이벤트와 그 후에 어떤일이 일어나는지 알려주는 콜백함수와 연결해준 다는 뜻이다. 이벤트 바인딩이는 총 3가지 방법이 있는데, HTML이벤트 핸들러, 전통적인 DOM핸들러, EventListener을 이용한 핸들러가있다."
        },
        {
            "id": 48,
            "exam": "라이브러리, 프레임워크의 정의를 간단하게 해본다면?",
            "answer": "라이브러리는 응용프로그램 개발을 위해 필요한 기능을 모아놓은 소프트웨어이고, 기능 사용법은 사용자가 결정합니다. 리액트가 UI를 만들기 위한 대표적인 자바스크립트의 라이브러리이다. / 프레임워크는 소프트웨어 개발을 위한 개발 환경, 토대, 기반시설을 제공하는 것이고 프로그래머는 프레임워크가 제공하는 전체적인 규칙을 따라가면서 개발해야한다. 코드를 프레임워크가 제어하는것이 라이브러리와의 차이점이다."
        },
        {
            "id": 49,
            "exam": "NPM이란?",
            "answer": "Node Packaged Manager의 약자로, NPM은 Node.js 로 만들어진 모듈을 웹에서 받아서 설치하고 관리해주는 프로그램이다. -> 자바스크립트 패키지 매니저고 Node.js에서 사용할 수 있는 모듈들을 패키지화에서 모아둔 저장소 역할이며 설치, 관리를 수행할 수 있는 CLI를 제공한다. 많은 자바스크립트 프로그래머들이 유용한 패키지들을 만들어 npm에 코드를 공개한다."
        },
        {
            "id": 50,
            "exam": "크로스 브라우징이란?",
            "answer": "어떤 환경에서 접근하여도 동등하게 작동하는 것을 말한다. 웹 표준 기술을 채용하여 다른 기종/플랫폼에 따라 달리 구현되는 기술을 비슷하게 만듬과 동시에 어느 한쪽에 최적화되어 치우치지 않도록 공통요소를 사용하여 웹 페이지를 제작하는 기법이다. 쉽게 말하자면 익스플로러에서 이용할 수 있던 사이트가 크롬이나 오페라에서는 보이지 않아 이용할 수 없는 것을 크로스 브라우징을 이용하여 사이트를 100% 이용할 수 있게 만드는 기술이다. 크로스 브라우징을 해야하는 이유는, 여러가지 브라우저들은 각각 다른 속성을 가지고 있기 때문에(즉, 각각의 렌더링 엔진이 다르기 때문에) 동일한 코드를 작성하더라도 브라우저마다 화면이 다르게 보일 수 있기 때문이다. 내가 쓰는 css가 사용되지 않는 브라우저를 can I use 사이트 같은 곳에서 확인하고, 제이쿼리 라이브러리를 사용하거나, css 속성 앞에 브라우져별 접두사인 벤더 프리픽스를 사용하는 것도 해결 방법이다."
        },
        {
            "id": 51,
            "exam": "*원시값과 참조값(array, object)의 차이점을 메모리 관점에서 설명해주세요",
            "answer": "원시값은 복제할 때 값이 담긴 주솟값을 바로 복제하고, 참조형은 값이 담긴 주소값들로 이루어진 묶음을 가리키는 주솟값을 복제한다. 원시값은 불변값이므로 원시값을 재 할당하면 새로운 메모리 공간을 확보하고 재 할당한 값을 저장하고 참조하던 메모리 공간 주소를 변경한다. 참조값은 가변값이므로 객체가 할당된 메모리 공간에는 실제 객체의 주소가 저장된다. 객체를 할당한 변수는 재할당없이 객체를 직접 변경할 수 있다. 프로퍼티를 동적으로 추가할 수 있고, 갱신, 삭제도 가능하다."
        },
        {
            "id": 52,
            "exam": "리액트의 useCallback, useEffect등을 사용할 때 의존성 배열을 받게 됩니다. 이 배열의 역할은 무엇인가요?",
            "answer": "useEffect의 의존성 배열은 두 번째 매개변수로, 의존성 배열의 내용이 변경되었을 경우, 부수 효과 함수(이펙트 함수)가 실행된다. 의존성 배열안의 값이 바뀔때만 렌더링 되는 특성을 이용해 state 혹은 props값이 변경될 때 특정 함수를 실행하거나, 컴포넌트가 마운트 될 때 API를 이용해 데이터를 가져오거나 하는데 사용된다. 빈 배열을 넣게 되면 최초 마운트 될 때 한번만 호출되도록 할 수 있다. 이펙트 내부에서 사용되는 모든 변수는 deps에 명시를 해야 버그가 발생하지 않는다. -> useCallback은 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용하는 훅으로 함수 안에서 사용하는 상태나 props가 있다면 의존성 배열에 추가하게 된다. 추가하지 않으면 함수 내에서 해당 값들을 참조할 때 가장 최신의 값을 참조할 것이라는 보장이 없다. 의존성 배열에 넣은 값이 변할 때만 함수를 새로 만들게 된다.(useMemo도 포함)"
        },
        {
            "id": 53,
            "exam": "'attribute'와 'property'의 차이점은 무엇인가요?",
            "answer": "attribute는 HTML요소의 추가적인 정보를 전달하고 이름=값 이렇게 쌍으로 온다. property는 attribute에 대한 HTML DOM트리 내에서의 표현이다. 둘의 차이: attribute는 HTML 텍스트 문서에 있는 것이고, property는 HTML DOM트리에 있는 것이다. attribute는 변하지 않고, property는 변할 수 있다.(ex. checkbox)"
        },
        {
            "id": 54,
            "exam": "*자바스크립트의 this는 몇가지로 추론될 수 있는지?",
            "answer": "전역범위에서 사용될 때 전역객체를 가르킨다. 함수에서 사용될 때도 전역객체를 가르킨다. 객체에 속한 메소드에서 사용될때는 그 메소드의 객체를 가르킨다. *객체에 속한 메소드의 내부함수에서 사용될 때는 전역객체를 가르킨다. 생성자 함수로 생성됐을 땐 생성된 새로운 객체를 가르킨다."
        },
        {
            "id": 55,
            "exam": "Function.prototype.bind을 설명하세요.",
            "answer": "새로운 함수를 반환한다. 따라서 보통 변수를 할당하여 호출하는 형태로 사용하며, 첫번째 인자로는 this 키워드를 지정하고, 뒤의 인자들은 bind 된 함수에 매개변수로 제공된다."
        },
        {
            "id": 56,
            "exam": "콜백 함수란?",
            "answer": "다른함수의 인자로써 이용되는 함수이며, 제어권도 함께 위임한 함수다. 비동기 처리 시 콜백함수를 사용한다. 콜백지옥에 빠지면 들여쓰기 수준이 높아지며 가독성이 떨어지기 때문에 Promise나 async/await를 이용해 보완할 수 있다. -> 함수를 등록하기만 하고 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출하는 함수!"
        },
        {
            "id": 57,
            "exam": "리액트와 제이쿼리의 차이점은?",
            "answer": "둘다 JS 라이브러리이다. React는 가상 DOM을 사용하는 라이브러리인데, 제이쿼리는 실제 DOM을 조작한다. -> 가상 DOM을 이용하는 것이 렌더링 과정이 빠르고, 그렇다 보니 실제 DOM을 조작하는 제이쿼리의 선호도가 떨어지는 것이다."
        },
        {
            "id": 58,
            "exam": "event.target 과 event.currentTarget의 차이점은?",
            "answer": "어떤것을 반환하느냐의 차이인데, e.target는 부모로부터 이벤트가 위임되어 발생하는 자식의 위치, 내가 클릭한 자식요소를 반환한다. 하지만 e.currentTarget는 이벤트가 부착된 부모의 위치를 반환한다."
        },
        {
            "id": 59,
            "exam": "Map()과 Set()의 설명 및 차이점은?(잘 모름)",
            "answer": "Map은 key가 있는 데이터를 저장한다. 객체와 비슷한면이 있지만, 키에 다양한 자료형을 허용을한다. 예를들어 객체의 키는 무조건 문자형이지만, Map에는 키의 자료형에 제한이 없다. 주의 사항은 객체처럼 Map[key]형태를 사용하면 일반 객체로 취급하기 때문에 안쓰는게 좋다. / Set은 중복을 허용하지 않는 값을 모아두는 객체다. new Set(iterable) 이런식으로 선언을 한다. 요소의 유무를 판단할때 Array.find보다 Set.has()가 더 효율적이다."
        },
        {
            "id": 60,
            "exam": "TDD란?",
            "answer": "Test-Driven Development의 약자로 '테스트 주도 개발'이라는 뜻이다. 우선 테스트 코드를 작성 한 후 구현을 하는 방식이다. 3가지의 절차가 있는데 실패>성공>리팩토링이 서로 꼬리를 물고 이뤄진다. -> TDD를 진행하면 테스트 케이스를 작성할 때 주로 작은 단위로 만들기 때문에 코드가 방대해지지 않고, 코드의 모듈화가 자연스럽게 이뤄진다."
        },
        {
            "id": 61,
            "exam": "useEffect란?",
            "answer": "컴포넌트가 렌더링 되거나 업데이트 될 때 그 안에 있는 기능을 실행할 수 있는 React Hooks중 하나다. 컴포넌트의 특정 값이 업데이트 될 때 해당 기능으로 작동시키고 싶으면 두번째 파라미터의 배열에 해당 값을 기재하면 된다. 두번째 파라미터에 빈 배열로 정의하면 한번만 호출되게 하는 것이다."
        },
        {
            "id": 62,
            "exam": "import와 require의 차이점은 무엇인가요?",
            "answer": "import와 require 모두 외부 라이브러리나 다른 파일을 불러오는 동일한 목적을 가지고있다. import의 경우 ES6에서 도입되었기때문에 babel과 같은 ES6 코드를 변환해주는 도구 없이는 사용하지 못한다. require()는 변수에 할당하듯이 불러와야한다."
        },
        {
            "id": 63,
            "exam": "스코프란? 스코프체인이란 무엇인가요?",
            "answer": "스코프는 어떤 변수들에 접근할 수 있는 유효범위로 코드 어디서든 참조할 수 있는 전역스코프, 함수 자신과 하위 함수에서만 참조할 수 있는 지역스코프가있다. / 내부함수는 호출된 변수를 찾기위해 먼저 자신의 스코프에서 찾고 없으면 한단계씩 외부로 나가면서 찾는다. 이렇게 꼬리를 물고 계속 범위를 넓히면서 찾는 관계를 스코프 체인이라고 부른다. -> GET은 데이터의 변형 위험이 없기때문에 POST보다 안전하다고 간주된다. POST요청은 클라이언트에서 서버로 전송할 때 추가적인 데이터를 body에 포함할 수 있지만 GET요청은 필요한 데이터를 URL에 포함하여 요청한다."
        },
        {
            "id": 64,
            "exam": "HTTP요청 메소드 POST와 GET의 차이점은 무엇인가요?",
            "answer": "GET은 주로 데이터를 읽거나 검색할때 사용되는 메소드인 반면 POST는 update나 create할 때 사용된다. (예: 검색페이지=get요청, 비번 수정 form=post요청)"
        },
        {
            "id": 65,
            "exam": "프로세스와 스레드에 대해 설명해주세요.",
            "answer": "프로세스: 운영체제로부터 시스템 자원을 할당받는 작업의 단위(메모리에 올라와 실행되고 있는 프로그램을 의미) / 스레드: 프로세스 내에서 실행되는 여러 흐름의 단위(같은 프로세스 안에 있는 여러 스레드들은 같은 힙 공간을 공유한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.)"
        }
        ,
        {
            "id": 66,
            "exam": "*HTTP란 무엇인가?",
            "answer": "HTTP는 HyperText Transfer Protocol의 줄임말로, 직역하면 하이퍼텍스트 전달 프로토콜이다. HTTP는 인터넷에서 데이터를 주고 받을 수 있는 프로토콜이다. HTTP는 웹 브라우저와 웹 서버의 소통을 위해 디자인되었으며, 전통적인 클라이언트-서버 아키텍처 모델에서 클라이언트가 HTTP 메시지 양식에 맞춰 요청을 보내면, 이에 서버는 HTTP 메시지 양식에 맞춰 응답을 한다. HTTP는 특정 상태를 유지하지 않는 무상태성(Stateless)이 특징이다."
        },
        {
            "id": 67,
            "exam": "*실행 컨텍스트에 대해 설명해주세요.",
            "answer": "실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로, 자바스크립트의 동적 언어로서의 성격을 가장 잘 파악할 수 있는 개념이다. -> 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 실행 컨텍스트는 곧 자바스크립트의 핵심 원리다.(전역 실행 컨텍스트 > 함수 실행 컨텍스트 > eval() 실행 컨텍스트 등 존재)"
        },
        {
            "id": 68,
            "exam": "불변성을 유지하려면 어떻게 해야하나요?",
            "answer": "간단하게는 const 선언자로 상수 선언을 하는 방법이 있습니다. 추가로 JS는 객체에 불변성을 유지할 수 있도록 별도의 객체(Object) 메서드를 지원하고 있으며, 불변성 강도에 따라 사용할 수 있도록 freeze(), seal(), preventExtensions() 3가지를 제공합니다. freeze를 가장 많이 사용하며 수정 및 삭제도 불가능하다."
        },
        {
            "id": 69,
            "exam": "*CSS 애니메이션과 JS 애니메이션의 차이",
            "answer": "transform 의 translate 를 사용해서 구현할 수 있는 애니메이션을 JavaScript의 style.top 과 style.left 속성을 변화 시키게 되어 브라우저 렌더링 과정에서 layout 이나 paint 단계를 거쳐야 할 경우가 생길 수 있기 때문에 성능 개선에 효율적이지 않을 수 있습니다."
        },
        {
            "id": 70,
            "exam": "Context API와 Redux를 비교해주세요.",
            "answer": "Context API는 context도 새로 만들고 provider 설정도 하고 각 context를 편하게 사용하기 위해 커스텀 Hook을 만들어 사용해야 하는데, Redux에서는 편리하게도 여러 기능이 존재한다. context API는 기능별로 관리를 하기때문에 번거롭고 Redux는 글로벌 상태를 하나의 커다란 상태 객체에 넣어서 사용하기 때문에 관리가 용이하다."
        },
        {
            "id": 71,
            "exam": "*쿠키, 세션, 웹스토리지(localstorage)의 차이에 대해 설명해주세요.",
            "answer": "쿠키: 용량이 작고 만료기한이 있으며 보안에 취약하다. / 세션: 브라우저를 종료하면 삭제됨, 서버에 데이터를 저장함, 사용자가 많아질수록 서버 메모리를 많이 차지해서 부하가 옴.  / 웹스토리지: 넉넉한 저장 용량, 원시형 데이터 및 객체 저장 가능, 삭제하지 않는 이상 지워지지 않음."
        },
        {
            "id": 72,
            "exam": "웹사이트 성능 최적화에는 어떤 방법이 있나요?",
            "answer": "웹팩(하나의 파일로 묶여있어 쉽게 불러옴) 사용 / style 태그는 상단, js 태그는 하단에 작성 / js의 공백 줄이기 / HTML내 불필요한 태그 제거 / reflow,repaint를 고려한 스타일 작성 / 사용하지 않는 css 제거 / 스프라이트 이미지 기법 사용 / 이미지 크기 최적화 / 애니메이션은 js보다 css를 최대한 활용하기 / 헤더에 만료기한 넣기 / SEO / CDN(Content Delivery Network) 사용 / 파일 수 줄이기 / 라이브러리 의존도 낮추기"
        },
        {
            "id": 73,
            "exam": "Cascading에 관해서 설명해주세요.",
            "answer": "Cascading은 '위에서 아래로 상속, 종속하는' 이라는 의미를 내포하고 있습니다. 따라서 적용된 여러 스타일을 중에서 어떤 스타일로 브라우저에 렌더링할지 결정하는 원리로 이해할 수 있습니다. -> Cascading은 스타일 우선순위 기준에 따라 보여지는 원리입니다."
        },
        {
            "id": 74,
            "exam": "시맨틱 마크업에 대해 설명해주세요.",
            "answer": "Semantic은 '의미론'이라는 뜻입니다. HTML을 시멘틱하게 마크업한다는 것은 의미론적인 요소를 사용하여 문서를 만든다는 것을 의미합니다. 단순히 div와 span으로 이루어진 문서가 아니라 의미를 가진 태그 요소를 사용해 문서를 만드는 것입니다. -> 개발자도, 리더기도 문서를 이해하기 수월해진다."
        },
        {
            "id": 75,
            "exam": "Props Drilling에 대해 설명하고 해결법을 제시하세요",
            "answer": "Prop Drilling 은 props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정입니다. -> props를 너무 많이 전달하게되면 추적과 유지보수에 어려움이 생긴다. -> 전역 상태 라이브러리(Redux)를 사용하거나 children prop을 사용하기입니다."
        },
        {
            "id": 76,
            "exam": "Key Props를 사용하는 이유에 대해 설명해주세요.",
            "answer": "key는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 도와준다. 문자열도 사용할 수 있다. -> 보통 map()를 사용할 때 key값을 넣어주는 편"
        },
        {
            "id": 77,
            "exam": "SEO에 대해 설명해주세요.",
            "answer": "Search Engine Optimization의 약자로 검색엔진이라 불린다. -> 웹페이지의 노출 순위를 높이는 것의 중요함을 강조한 내용이다."
        },
        {
            "id": 78,
            "exam": "리플로우와 리페인트에 대해 설명해주세요.",
            "answer": "말 그대로 해당 요소를 다시 칠하고, 다시 플로우를 정하는 것. 리플로우: 렌더 과정 중 Layout 단계를 다시 거침 / 리페인트: 렌더 과정 중 paint 단계를 다시 거침"
        },
        {
            "id": 79,
            "exam": "(자료구조)스택과 큐의 차이점에 대해 설명해주세요.",
            "answer": "Stack: 첫째, LIFO(Last In First Out) : 마지막에 들어온 데이터가 먼저가 먼저 나가는 데이터 구조로, 흔히 후입선출 구조라고도 부릅니다. 둘째, FILO(First In Last Out) : 처음 들어온 데이터가 마지막에 나가는 데이터 구조로, 흔히 선입후출라고도 이야기합니다. / Queue: 순서는 FIFO(First In First Out) 선입선출입니다. -> 스택과 큐의 차이점은 제거에 있습니다. 스택은 가장 최근에 추가된 데이터를 제거하지만, 큐는 가장 처음에 들어왔던 데이터를 삭제한다."
        },
        {
            "id": 80,
            "exam": "FE 개발자가 되고 싶은 계기가 뭔가요?",
            "answer": "직접 눈으로 보고 확인하면서 뭔가를 구현하는 일이 적성에 잘 맞았어요. 프론트엔드의 매력은 사용자와 가장 가까운 곳에 있다는 점이에요. 내가 직접 짠 코드가 사용자가 직접 만나는 환경이라는 점이 마음에 들어서 프론트엔드라는 분야를 선택하게 되었습니다."
        },
        {
            "id": 81,
            "exam": "API란 무엇인가요?",
            "answer": "API는 프로그램들이 서로 상호작용하는 것을 도와주는 매개체(연결고리) -> API(Application Programming Interface)는 응용 프로그램에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다. 주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공합니다."
        },
        {
            "id": 82,
            "exam": "미들웨어란 무엇인가요?",
            "answer": "미들웨어는 운영 체제와 해당 운영 체제에서 실행되는 응용 프로그램 사이에 존재하는 소프트웨어. 즉, 분산 컴퓨팅 환경에서 응용 프로그램과 프로그램이 운영되는 환경 간에 원만한 통신이 이루어질 수 있도록 제어해주는 소프트웨어이다. -> 표준화된 인터페이스 제공 / 체계가 다른 업무와 상호 연동 가능 / 분산된 업무를 동시에 처리 가능 / 부하의 분산 기능"
        }
    ]
}